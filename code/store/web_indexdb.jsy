const web_indexdb_store_proto = @{}
  async batch_store(u8_kv_pairs) ::
    const {kvdb, txn_done} = this._txn_rw()
    for const [u8_key, u8_value] of u8_kv_pairs ::
      kvdb.put @ u8_value, u8_key

    await txn_done
    return true

  async batch_fetch(u8_key_list) ::
    const {kvdb, txn_done} = this._txn_ro()
    const ans = []
    for const u8_key of u8_key_list ::
      ans.push @# u8_key, kvdb.get @ u8_key

    await txn_done
    for const tpl of ans ::
      tpl[1] = tpl[1].result
    return ans

  async batch_exists(u8_key_list) ::
    const {kvdb, txn_done} = this._txn_ro()
    const ans = []
    for const u8_key of u8_key_list ::
      ans.push @# u8_key, kvdb.count @ u8_key

    await txn_done
    for const tpl of ans ::
      tpl[1] = tpl[1].result
    return ans


export async function web_indexdb_store(db_name='phorbas', store_name='kv') ::
  const {txn_ro, txn_rw} = await
    _idb_with_bound_txns(db_name, store_name)

  return Object.create @ web_indexdb_store_proto,
    @{} _txn_ro: @{} value: txn_ro
        _txn_rw: @{} value: txn_rw


async function _idb_with_bound_txns(db_name, store_name) ::
  const idb = await new Promise @\ resolve, reject ::
    const req = indexedDB.open(db_name, 1)
    req.onupgradeneeded = @=> req.result.createObjectStore(store_name)
    req.onsuccess = @=> resolve @ req.result
    req.onerror = @=> reject @ req.error

  return @{}
    txn_ro: _idb_txn.bind(null, idb, store_name, 'readonly')
    txn_rw: _idb_txn.bind(null, idb, store_name, 'readwrite')
  
function _idb_txn(idb, store_name, mode) ::
  const txn = idb.transaction(store_name, mode)
  return @{} txn
    kvdb: txn.objectStore(store_name)
    txn_done: new Promise @\ resolve, reject ::
      txn.oncomplete = resolve
      txn.onabort = txn.onerror = @=> reject @ txn.error


