import { vec_equal, vec_prefix, vec_longest_prefix } from './_hamt_vec_utils.jsy'
import { hamt_replace_at, hamt_child_pair } from './hamt_ops.jsy'

export default hamt_add_key
export async function hamt_add_key(chain, hamt_node, key_public) ::
  const {h, amt} = hamt_node
  const idx = vec_prefix(h, key_public)
  const ki = key_public[idx]
  const current = amt[ki]

  if undefined === current ::
    // no existing entry; replace empty entry
    return hamt_replace_at @
      chain, hamt_node, ki,
      key_public

  else if Array.isArray(current) ::
    // existing TRIE node, denoted by being a single-item Array of [hamt_key_secret]
    const cur_child_node = await hamt_node.fetch(current[0])
    const new_child_node = await hamt_add_key @
      chain, cur_child_node, key_public

    if cur_child_node === new_child_node ::
      // unchanged child HAMT -- no change required
      return hamt_node

    return hamt_replace_at @
      chain, hamt_node, ki,
      [await new_child_node.key_secret()]

  else if vec_equal(hex_key, current) ::
    // existing identical key -- no change required
    return hamt_node

  else ::
    // existing but different key
    const new_child_node = hamt_child_pair @
      chain, hamt_node, h, current, key_public

    return hamt_replace_at @
      chain, hamt_node, ki,
      [await new_child_node.key_secret()]

