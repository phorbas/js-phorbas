import { cbor_decode, cbor_encode } from 'cbor-codec'

import hamt_add_key from './hamt_add_key.jsy'
import hamt_merge from './hamt_merge.jsy'

export function phorbas_hamt(opaque) ::
  const _wm_u8 = new WeakMap()
  const _wm_keyctx = new WeakMap()

  const _hamt_node_ = @{}
    __proto__: hamt_node_proto
    u8_local() :: return _wm_u8.get(this)
    u8_retain(u8) :: _wm_u8.set(this, u8); return this
    u8_free() :: _wm_u8.delete(this); return this

    new_hamt: ({h, amt}) => @:
      __proto__: _hamt_node_.__base__
      h, amt

    async hamt_key() ::
      return (await this.keyctx()).key_secret
    async keyctx(hamt_key) ::
      let keyctx = _wm_keyctx.get(this)
      if undefined === keyctx ::
        keyctx = undefined !== hamt_key
          ? opaque.from_key(hamt_key)
          : opaque.from_content(this.encode())

        _wm_keyctx.set(this, keyctx)
        keyctx = await keyctx
        _wm_keyctx.set(this, keyctx)
      return keyctx

    async exists(hamt_key) ::
      const keyctx = await this.keyctx(hamt_key)
      return await keyctx.exists()
    async fetch(hamt_key) ::
      const keyctx = await this.keyctx(hamt_key)
      const res = await keyctx.fetch()
      return res ? this.decode(res) : res
    async store() ::
      const keyctx = await this.keyctx()
      await keyctx.store()
      return this


  const _hamt_ = @{}
    __proto__: hamt_proto, _hamt_node_
    with_root(root) ::
      return root === this.root ? this :
        @{} __proto__: _hamt_.__base__, root
 
  _hamt_node_.__base__ = _hamt_node_
  _hamt_.__base__ = _hamt_

  return _hamt_.with_root(null)


const hamt_proto = @{}
  __proto__: null

  new_root() ::
    return this.with_root @
      this._hamt_node_.new_hamt @:
        h: new Uint8Array(0), amt: []

  async load_root(hamt_key) ::
    return this.with_root @
      await this._hamt_node_.fetch(hamt_key)

  async _store_chain(chain) ::
    for const ea of chain ::
      await ea.store()

  async add_key(keyctx) ::
    return this.add_key_u8 @
      await (await keyctx).key_public

  async add_key_u8(key_public) ::
    const chain = []
    const root = await hamt_add_key @ chain, this.root, key_public
    await this._store_chain(chain)
    return this.with_root(root)

  async merge(hamt_other) ::
    if undefined === this.root ::
      return this.with_root(hamt_other)

    const chain = []
    const root = await hamt_merge @ chain, this.root, hamt_other.root || hamt_other

    // TODO: fetch all non-present entries discovered during merge
    await this._store_chain(chain)
    return this.with_root(root)


const hamt_node_proto = @{}
  __proto__: null

  encode() ::
    let u8 = this.u8_local()
    if undefined === u8 ::
      const {h,amt} = this
      this.u8_retain @
        u8 = cbor_encode({h,amt})
    return u8

  decode(u8) ::
    return this.new_hamt(cbor_decode(u8)).u8_retain(u8)

