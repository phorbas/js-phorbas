import { cbor_decode, cbor_encode } from 'cbor-codec'
import { vec_equal } from './_hamt_vec_utils.jsy'

import {hamt_add_key} from './hamt_add_key.jsy'
import {hamt_merge} from './hamt_merge.jsy'
import {hamt_store} from './hamt_store.jsy'
import {hamt_sync_queue} from './hamt_sync.jsy'


const _map_noop = @{} get(){}
export function phorbas_hamt(opaque) ::
  const _wm_u8 = new WeakMap()
  const _wm_keyctx = new WeakMap()
  const _wm_deps = new WeakMap()

  const _hamt_node_ = @{}
    __proto__: hamt_node_proto
    get opaque() :: return opaque
    u8_local() :: return _wm_u8.get(this)
    u8_retain(u8) :: _wm_u8.set(this, u8); return this
    u8_free() :: _wm_u8.delete(this); return this

    new_hamt: ({h, amt}) => @:
      __proto__: _hamt_node_.__base__
      h, amt

    dep_at(ki) :: return (_wm_deps.get(this) || _map_noop).get(ki)
    local_deps() :: return _wm_deps.get(this)
    deps_from(...args) ::
      const deps = new Map()
      for let each of args.filter(Boolean) ::
        if undefined !== each.hamt_key ::
          each = _wm_deps.get(each) || []

        for const [ki, inner] of each ::
          deps.set(ki, inner)

      _wm_deps.set(this, deps)
      return this

    keyctx_for: opaque.from_key.bind(opaque)

    async keyctx(hamt_key) ::
      let keyctx = _wm_keyctx.get(this)
      if undefined === keyctx ::
        keyctx = undefined !== hamt_key
          ? opaque.from_key(hamt_key)
          : opaque.from_content(this.encode())

        _wm_keyctx.set(this, keyctx)
        keyctx = await keyctx
        _wm_keyctx.set(this, keyctx)
      return keyctx


  const _hamt_ = @{}
    __proto__: hamt_proto, _hamt_node_
    with_root(root) ::
      return root === this.root ? this :
        @{} __proto__: _hamt_.__base__, root
 
  _hamt_node_.__base__ = _hamt_node_
  _hamt_.__base__ = _hamt_

  return _hamt_.with_root(null)


const hamt_proto = @{}
  __proto__: null

  new_root() ::
    return this.with_root @
      this._hamt_node_.new_hamt @:
        h: new Uint8Array(0), amt: []

  async load_root(hamt_key) ::
    const [root, keyctx] = await
      this._hamt_node_.fetch_keyctx(hamt_key)
    return this.with_root(root)

  async store_root(attr=true, opt={}) ::
    const {root} = this
    await hamt_store(root, opt)
    return root.as_attr(attr)

  async add_keyctx(keyctx) ::
    return this.add_key_u8 @
      await (await keyctx).key_loc

  async add_key_u8(key_loc) ::
    const root = await hamt_add_key @ this.root, key_loc
    return this.with_root @ await root

  async add_key(key) ::
    key = await key
    return this.add_key_u8 @
      key.key_loc || key

  async merge(hamt_other, opt={}) ::
    let {root} = this
    if undefined === root ::
      root = this.new_root().root

    const o_root = hamt_other.root || hamt_other
    const sync_q = hamt_sync_queue(root, o_root, opt)

    const ts_cutoff = Date.now() + 1000 // ts_duration
    while true ::
      await sync_q.prepare_sync()

      const merged_root = await hamt_merge @
        sync_q.sync, root, o_root

      const count = await sync_q.finish_sync()
      if 0 === count ::
        return this.with_root(merged_root)
      else if ts_cutoff < Date.now() ::
        return false


const hamt_node_proto = @{}
  __proto__: null

  encode() ::
    let u8 = this.u8_local()
    if undefined === u8 ::
      const {h,amt} = this
      this.u8_retain @
        u8 = cbor_encode({h,amt})
    return u8

  decode(u8) ::
    return this.new_hamt(cbor_decode(u8)).u8_retain(u8)

  async as_attr(attr) ::
    return (await this.keyctx()).as_attr(attr)
  async hamt_key() ::
    return this.as_attr('key_ref')
  async exists(hamt_key) ::
    const keyctx = await this.keyctx_for(hamt_key)
    return await keyctx.exists()

  async fetch_keyctx(hamt_key) ::
    const keyctx = await this.keyctx_for(hamt_key)
    const res = await keyctx.fetch()
    const node = res ? this.decode(res) : res
    return [node, keyctx]

  async fetch_dep(ki, [hamt_key]) ::
    const dep = this.dep_at(ki, hamt_key)
    if undefined !== dep ::
      if vec_equal @ hamt_key, await dep.hamt_key() ::
        return @[] dep, dep.keyctx()
    return await this.fetch_keyctx(hamt_key)

  *iter_dependency_tree() ::
    const children = this.local_deps()
    if undefined !== children ::
      for const [ki, inner] of children ::
        yield * inner.iter_dependency_tree()
    yield this

