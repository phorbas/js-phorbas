import { cbor_decode, cbor_encode } from 'cbor-codec'
import { vec_equal } from './_hamt_vec_utils.jsy'

import hamt_add_key from './hamt_add_key.jsy'
import hamt_merge from './hamt_merge.jsy'


const _map_noop = @{} get(){}
export function phorbas_hamt(opaque) ::
  const _wm_u8 = new WeakMap()
  const _wm_keyctx = new WeakMap()
  const _wm_deps = new WeakMap()

  const _hamt_node_ = @{}
    __proto__: hamt_node_proto
    get opaque() :: return opaque
    u8_local() :: return _wm_u8.get(this)
    u8_retain(u8) :: _wm_u8.set(this, u8); return this
    u8_free() :: _wm_u8.delete(this); return this

    new_hamt: ({h, amt}) => @:
      __proto__: _hamt_node_.__base__
      h, amt

    dep_at(ki) :: return (_wm_deps.get(this) || _map_noop).get(ki)
    local_deps() :: return _wm_deps.get(this)
    deps_from(...args) ::
      const deps = new Map()
      for let each of args.filter(Boolean) ::
        each = undefined !== each.hamt_key
          ? _wm_deps.get(each) || [] : each

        for const [ki, inner] of each ::
          deps.set(ki, inner)

      _wm_deps.set(this, deps)
      return this


    async keyctx(hamt_key) ::
      let keyctx = _wm_keyctx.get(this)
      if undefined === keyctx ::
        keyctx = undefined !== hamt_key
          ? opaque.from_key(hamt_key)
          : opaque.from_content(this.encode())

        _wm_keyctx.set(this, keyctx)
        keyctx = await keyctx
        _wm_keyctx.set(this, keyctx)
      return keyctx



  const _hamt_ = @{}
    __proto__: hamt_proto, _hamt_node_
    with_root(root) ::
      return root === this.root ? this :
        @{} __proto__: _hamt_.__base__, root
 
  _hamt_node_.__base__ = _hamt_node_
  _hamt_.__base__ = _hamt_

  return _hamt_.with_root(null)


const hamt_proto = @{}
  __proto__: null

  new_root() ::
    return this.with_root @
      this._hamt_node_.new_hamt @:
        h: new Uint8Array(0), amt: []

  async load_root(hamt_key) ::
    return this.with_root @
      await this._hamt_node_.fetch(hamt_key)

  async store_root(attr=true) ::
    const {root} = this
    await root.opaque.storage.batch_store @
      iter_store_pairs @ root
    return root.as_attr(attr)

  async add_keyctx(keyctx) ::
    return this.add_key_u8 @
      await (await keyctx).key_public

  async add_key_u8(key_public) ::
    const root = await hamt_add_key @ this.root, key_public
    return this.with_root @ await root

  async add_key(key) ::
    key = await key
    return this.add_key_u8 @
      key.key_public || key

  async merge(hamt_other) ::
    if undefined === this.root ::
      return this.with_root(hamt_other)

    const root = await hamt_merge @ this.root, hamt_other.root || hamt_other

    // TODO: fetch all non-present entries discovered during merge
    return this.with_root(root)


const hamt_node_proto = @{}
  __proto__: null

  encode() ::
    let u8 = this.u8_local()
    if undefined === u8 ::
      const {h,amt} = this
      this.u8_retain @
        u8 = cbor_encode({h,amt})
    return u8

  decode(u8) ::
    return this.new_hamt(cbor_decode(u8)).u8_retain(u8)

  async as_attr(attr) ::
    return (await this.keyctx()).as_attr(attr)
  async hamt_key() ::
    return this.as_attr('key_secret')
  async exists(hamt_key) ::
    const keyctx = await this.keyctx(hamt_key)
    return await keyctx.exists()

  async fetch_dep(ki, [hamt_key]) ::
    const dep = this.dep_at(ki, hamt_key)
    if undefined !== dep ::
      if vec_equal @ hamt_key, await dep.hamt_key() ::
        return dep
    return this.fetch(hamt_key)

  async fetch(hamt_key) ::
    const keyctx = await this.keyctx(hamt_key)
    const res = await keyctx.fetch()
    return res ? this.decode(res) : res

  *iter_dependency_tree() ::
    const children = this.local_deps()
    if undefined !== children ::
      for const [ki, inner] of children ::
        yield * inner.iter_dependency_tree()
    yield this


function _as_store_pair(kx) :: return kx.as_store_pair()
function * iter_store_pairs(hamt_root) ::
  for const node of hamt_root.iter_dependency_tree() ::
    yield node.keyctx().then @ _as_store_pair

