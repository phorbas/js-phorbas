import {phorbas_hamt_node} from './hamt_node.jsy'
import {hamt_add_key} from './hamt_add_key.jsy'
import {hamt_merge} from './hamt_merge.jsy'
import {hamt_store} from './hamt_store.jsy'
import {hamt_sync_queue} from './hamt_sync.jsy'

export function phorbas_hamt(opaque) ::
  const _hamt_ = Object.create @ hamt_proto, @{}
    _hamt_node_: @{} value: phorbas_hamt_node(opaque)
    opaque: @{} value: opaque
    storage: @{} value: opaque.storage

  _hamt_.__base__ = _hamt_
  return _hamt_.with_root(null)


const hamt_proto = @{}
  __proto__: null

  new_root() ::
    return this.with_root @
      this._hamt_node_.new_hamt @:
        h: new Uint8Array(0), amt: []

  with_root(root) ::
    return root === this.root ? this :
      @{} __proto__: this.__base__, root
 
  async load_root(hamt_key) ::
    const [root, keyctx] = await
      this._hamt_node_.fetch_keyctx(hamt_key)
    return this.with_root(root)

  async store_root(attr=true, opt={}) ::
    const {root} = this
    await hamt_store(root, opt)
    return root.as_attr(attr)

  async add_keyctx(keyctx, skip_exists_check) ::
    return this.add_key_u8 @
      await (await keyctx).key_loc
      skip_exists_check

  async add_key_u8(key_loc, skip_exists_check) ::
    const {root, storage} = this
    if skip_exists_check || await storage.exists_at(key_loc) ::
      const merged_root = await
        hamt_add_key @ root, key_loc
      return this.with_root(merged_root)
    else throw new Error('No stored entry for key')

  async add_key(key, skip_exists_check) ::
    key = await key
    return this.add_key_u8 @
      key.key_loc || key
      skip_exists_check

  async merge(hamt_other, opt={}) ::
    let {root} = this
    if undefined === root ::
      root = this.new_root().root

    const o_root = hamt_other.root || hamt_other
    const sync_q = hamt_sync_queue(root, o_root, opt)

    const ts_cutoff = Date.now() + @ opt.ts_duration || 1000
    while true ::
      await sync_q.prepare_sync()

      const merged_root = await hamt_merge @
        sync_q.sync, root, o_root

      const count = await sync_q.finish_sync()
      if 0 === count ::
        return this.with_root(merged_root)

      else if ts_cutoff < Date.now() ::
        throw new Error('timeout')

