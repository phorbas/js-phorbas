import { vec_equal, vec_prefix } from './_hamt_vec_utils.jsy'
import { hamt_add_key } from './hamt_add_key.jsy'
import { hamt_replace_at, hamt_child_single, hamt_child_pair, hamt_inner_tree } from './hamt_ops.jsy'


export default hamt_merge
export async function hamt_merge(hamt_a, hamt_b) ::
  const {h: h_a} = hamt_a, {h: h_b} = hamt_b
  const idx = vec_prefix(h_a, h_b)
  const ki = h_b[idx]

  if undefined === ki ::
    return hamt_merge_peers @ hamt_a, hamt_b

  const current = hamt_a.amt[ki]
  if undefined === current ::
    // create inner tree and merge
    const join_tree = hamt_inner_tree @ h_a, hamt_b
    return hamt_replace_at @
      hamt_a, ki,
      [await join_tree.hamt_key()]
      [[ki, join_tree]]

  else if Array.isArray(current) ::
    const cur_child_node = await hamt_a.fetch_dep(ki, current)
    const new_child_node = await hamt_merge @
      cur_child_node, hamt_b

    if cur_child_node === new_child_node ::
      // unchanged child HAMT -- no change required
      return hamt_a

    return hamt_replace_at @
      hamt_a, ki,
      [await new_child_node.hamt_key()]
      [[ki, new_child_node]]

  else ::
    // create node for existing entry and recursively merge
    const child_node = hamt_child_single @ [], hamt_a, h_a, current
    const join_tree = await hamt_merge @ child_node, hamt_b

    return hamt_replace_at @
      hamt_a, ki,
      [await join_tree.hamt_key()]
      [[ki, join_tree]]




const _amt_merge = @{}
  async 'amt merge 0 0'(hamt_node, ki, e_a, e_b) ::
    return await hamt_child_pair @
      hamt_node, hamt_node.h,
      e_a, e_b

  async 'amt merge 0 1'(hamt_node, ki, e_a, e_b) ::
    return await hamt_add_key @
      await hamt_node.fetch_dep(ki, e_b),
      e_a

  async 'amt merge 1 0'(hamt_node, ki, e_a, e_b) ::
    return await hamt_add_key @
      await hamt_node.fetch_dep(ki, e_a),
      e_b

  async 'amt merge 1 1'(hamt_node, ki, e_a, e_b) ::
    return await hamt_merge_peers @
      await hamt_node.fetch_dep(ki, e_a),
      await hamt_node.fetch_dep(ki, e_b),


export async function hamt_merge_peers(hamt_a, hamt_b) ::
  const {h: h_a, amt: amt_a} = hamt_a
  const {h: h_b, amt: amt_b} = hamt_b
  if ! vec_equal(h_a, h_b) ::
    throw new Error @ 'HAMT nodes are not valid peers'

  if vec_equal @ await hamt_a.key_public(), await hamt_b.key_public() ::
    return hamt_a

  let changed = false, deps=new Map()
  const h=h_a, amt=amt_a.slice()
  for const ki in amt_b ::
    const e_b = amt_b[ki]
    if undefined === e_b :: continue

    changed = e_b
    const e_a = amt_a[ki]
    if undefined === e_a ::
      amt[ki] = e_b

    else ::
      const fn_merge = _amt_merge[`amt merge ${0|Array.isArray(e_a)} ${0|Array.isArray(e_b)}`]
      const node = await fn_merge @ hamt_a, ki, e_a, e_b
      deps.set(ki, node)
      amt[ki] = [await node.hamt_key()]

  return undefined === changed ? hamt_a
    : hamt_node
        .new_hamt @: h, amt
        .deps_from @ hamt_b, hamt_a, deps

