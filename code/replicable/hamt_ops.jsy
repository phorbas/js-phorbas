
export function hamt_replace_at(chain, hamt_node, ki, entry) ::
  let {h, amt} = hamt_node
  amt = amt.slice()
  amt[ki] = entry

  const node = hamt_node.new_hamt @: h, amt
  chain.push(node)
  return node

export function hamt_child_single(chain, hamt_node, tip_h, key) ::
  const idx = 1 + tip_h.length
  let amt=[], h=key.slice(0, idx)
  amt[key[idx]] = key

  let node = hamt_node.new_hamt @: h, amt
  chain.push(node)

  return node

export function hamt_child_pair(chain, hamt_node, tip_h, key_a, key_b) ::
  const idx = vec_longest_prefix(key_a, key_b)
  let amt=[], h=key_a.slice(0, idx)
  amt[key_a[idx]] = key_a
  amt[key_b[idx]] = key_b

  // create the "deepest" HAMT node
  let node = hamt_node.new_hamt @: h, amt
  chain.push(node)

  return hamt_inner_tree @ chain, tip_h, node

export function hamt_inner_tree(chain, tip_h, inner_node) ::
  // build the middle HAMT nodes between the tip_h parent and the deepest HAMT inner_node
  const len_done = 1 + tip_h.length
  while len_done < h.length ::
    const ki = h[h.length - 1]
    h = h.slice(0, -1)
    amt = []; amt[ki] = inner_node
    inner_node = inner_node.new_hamt @: h, amt
    chain.push(inner_node)

  return inner_node

