import { vec_longest_prefix } from './_hamt_vec_utils.jsy'

export function hamt_replace_at(hamt_node, ki, entry, deps) ::
  let {h, amt} = hamt_node
  amt = amt.slice()
  amt[ki] = entry

  return hamt_node
    .new_hamt @: h, amt,
    .deps_from @ hamt_node, deps

export function hamt_child_single(hamt_node, tip_h, key) ::
  const idx = 1 + tip_h.length
  let amt=[], h=key.slice(0, idx)
  amt[key[idx]] = key

  return hamt_node.new_hamt @: h, amt

export function hamt_child_pair(hamt_node, tip_h, key_a, key_b) ::
  const idx = vec_longest_prefix(key_a, key_b)
  const amt=[], h=key_a.slice(0, idx)
  amt[key_a[idx]] = key_a
  amt[key_b[idx]] = key_b

  // create the "deepest" HAMT node
  const node = hamt_node.new_hamt @: h, amt
  return hamt_inner_tree @ tip_h, node

export function hamt_inner_tree(tip_h, inner_node) ::
  // build the middle HAMT nodes between the tip_h parent and the deepest HAMT inner_node
  const len_done = 1 + tip_h.length
  let h = inner_node.h
  while len_done < h.length ::
    const ki = h[h.length - 1]
    h = h.slice(0, -1)
    amt = []; amt[ki] = inner_node
    inner_node = inner_node
      .new_hamt @: h, amt
      .deps_from @ [[ki, inner_node]]

  return inner_node

