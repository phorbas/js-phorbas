import {utf8_to_u8} from 'u8-utils'
import {keyctx_proto} from './keyctx.jsy'
import {with_store_api} from './_store_api.jsy'

const opaque_proto = @{}
  keyctx_proto: keyctx_proto
  kdf_ref: abstract_kdf
  kdf_loc: abstract_kdf

  with_storage(storage_impl) ::
    return this.with_store @
      with_store_api @ storage_impl

  with_store(store_api) ::
    const keyctx_proto = this.keyctx_proto.with_store(store_api)
    return Object.create @ this, @{}
      keyctx_proto: {value: keyctx_proto}
      store_api: {value: store_api}

  async from_content(raw_content) ::
    raw_content = await _u8content(raw_content)
    return this.from_key_content @ raw_content, raw_content

  async from_key_content(key_material, raw_content) ::
    key_material = await _u8arr(key_material)
    const key_ref = await this.kdf_ref(key_material)
    return this.from_key @ key_ref, raw_content

  async from_key(key_ref, raw_content) ::
    key_ref = await _u8arr(key_ref)
    const key_loc = await this.kdf_loc(key_ref)
    const keyctx = @{} __proto__: this.keyctx_proto, key_loc, key_ref

    if undefined !== raw_content ::
      raw_content = await _u8content(raw_content)
      keyctx.retain(raw_content)
    return keyctx


  async fetch(key_ref) ::
    const keyctx = await this.from_key(key_ref)
    return keyctx.fetch()
  async fetch_utf8(key_ref) ::
    const keyctx = await this.from_key(key_ref)
    return keyctx.fetch_utf8()
  async store(...args) ::
    const keyctx = await this.from_content(args.pop())
    return keyctx.store(args.pop())


async function _u8content(val) ::
  if null !== val && undefined !== val && ! @ val instanceof Uint8Array ::
    if val.then :: val = await val
    if ! @ val instanceof Uint8Array ::
      if 'string' !== typeof val ::
        val = new Uint8Array @ val
      else val = utf8_to_u8(val)
  return val

async function _u8arr(val) ::
  if null !== val && undefined !== val ::
    if val.then :: val = await val
    if ! @ val instanceof Uint8Array ::
      val = new Uint8Array @ val
  return val

function abstract_kdf(u8_to_hash) ::
  throw new Error @ 'Use concrete key derivation function like sha_256'



export ::
  opaque_proto,
  opaque_proto as opaque,
  opaque_proto as default,

