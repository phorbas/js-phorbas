
#IF PLAT_NODEJS
  import {createSecretKey, createCipheriv, createDecipheriv} from 'crypto'

  const aes_256_gcm__node = @{}
    async encrypt(raw_content, key_secret, key_public) ::
      const cipher = createCipheriv @
        'aes-256-gcm'
        createSecretKey @ key_secret.subarray(-32)
        key_public.subarray(-32)

      const lst = @[]
        cipher.update(raw_content)
        cipher.finish()
        cipher.getAuthTag() // NodeJS uses GCM auth tags of 128 bits (16 bytes)

      return new Uint8Array @ Buffer.concat(lst)

    async decrypt(enc_content, key_secret, key_public) ::
      const cipher = createDecipheriv @
        'aes-256-gcm'
        createSecretKey @ key_secret.subarray(-32)
        key_public.subarray(-12) // IV of 96 bits (12 bytes) 

      // NodeJS uses GCM auth tags of 128 bits (16 bytes)
      cipher.setAuthTag @ enc_content.subarray(-16)
      enc_content = enc_content.subarray(0, -16)

      return new Uint8Array @ Buffer.concat @#
        cipher.update(enc_content)
        cipher.finish()


  export const aes_256_gcm = aes_256_gcm__node



#ELIF PLAT_WEB
  const _import_aes_gcm_raw = aeskey =>
    crypto.subtle.importKey @ 'raw', aeskey.subarray(-32),
      {name: 'AES-GCM', length: 256}, false, ['encrypt', 'decrypt']

  const aes_256_gcm__web = @{}
    async encrypt(raw_content, key_secret, key_public) ::
      return new Uint8Array @ await crypto.subtle.encrypt @
        @{} name: 'AES-GCM', tagLength: 128,
            iv: key_public.subarray(-12) // IV of 96 bits (12 bytes) 
        await _import_aes_gcm_raw @ key_secret
        raw_content

    async decrypt(enc_content, key_secret, key_public) ::
      return new Uint8Array @ await crypto.subtle.decrypt @
        @{} name: 'AES-GCM', tagLength: 128,
            iv: key_public.subarray(-12) // IV of 96 bits (12 bytes) 
        await _import_aes_gcm_raw @ key_secret
        enc_content

  export const aes_256_gcm = aes_256_gcm__web



export default aes_256_gcm

