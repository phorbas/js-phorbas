import {u8_to_hex, u8_to_utf8} from 'u8-utils'

const _wm_key_hex = new WeakMap()
const _wm_ctx_content = new WeakMap()

const keyctx_proto = @{}
  cipher: abstract_cipher()
  storage: abstract_storage()
  kdf_cipher: key_secret => key_secret
  kdf_iv: key_public => key_public

  with_ctx({cipher, storage}) ::
    const props = @{}
    if cipher && cipher !== this.cipher ::
      props.cipher = @{} value: cipher

    if storage && storage !== this.storage ::
      props.storage = @{} value: storage
      props.key_store = @{} get:
        storage.uses_binary_key
          ? _get_binary_key
          : _get_hex_key

    return Object.create @ this, props


  hex_key: _get_hex_key

  local() :: return _wm_ctx_content.get(this)
  has_local() :: return undefined !== _wm_ctx_content.get(this)
  retain(raw_content) :: _wm_ctx_content.set(this, raw_content); return this
  free() :: _wm_ctx_content.delete(this); return this

  async store() ::
    const raw_content = this.local()
    if undefined === raw_content ::
      throw new Error('No associated raw_content')

    const {key_secret, key_public, key_store, cipher, storage} = this
    const enc_content = await cipher.encrypt @ raw_content,
      await this.kdf_cipher(key_secret)
      await this.kdf_iv(key_public)

    await storage.store_at(key_store, enc_content)
    return this

  fetch_utf8() ::
    return this.fetch().then(u8_to_utf8)

  async fetch() ::
    const raw_content = this.local()
    if undefined !== raw_content ::
      return raw_content

    const p = this._do_fetch()
    this.retain(p)
    return p

  async _do_fetch() ::
    const {key_secret, key_public, key_store, cipher, storage} = this
    const enc_content = await storage.fetch_at(key_store)
    if ! enc_content instanceof Uint8Array ::
      return enc_content

    const raw_content = await cipher.decrypt @ enc_content,
      await this.kdf_cipher(key_secret)
      await this.kdf_iv(key_public)

    this.retain(raw_content)
    return raw_content



function _get_hex_key() ::
  const {key_public} = this
  let r = _wm_key_hex.get(key_public)
  if undefined === r ::
    _wm_key_hex.set @ key_public, r = u8_to_hex(key_public)
  return r

function _get_binary_key() ::
  return this.key_public

function abstract_cipher() ::
  const warn = v => @
    console.warn @ 'Use concrete cipher like iso_aes_gcm'
    v

  return @{}
    async encrypt(raw_content, key_secret, key_public) ::
      return warn @ raw_content
    async decrypt(enc_content, key_secret, key_public) ::
      return warn @ enc_content

function abstract_storage() ::
  const warn = v => @
    console.warn @ 'Use a concrete storage implementation'
    v

  return @{}
    async store_at(key_store, enc_content) ::
      return warn()
    async fetch_at(key_store) ::
      return warn()



export ::
  keyctx_proto,
  keyctx_proto as keyctx,
  keyctx_proto as default,

