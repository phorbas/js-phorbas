//import js_map_store from '../store/js_map.jsy'
import {u8_to_utf8} from 'u8-utils'

const _wm_ctx_content = new WeakMap()

export default keyctx_proto
export const keyctx_proto = @{}
  //storage: js_map_store()
  with_storage(storage) ::
    return Object.create @ this, @{}
      storage: {value: storage}


  local() :: return _wm_ctx_content.get(this)
  has_local() :: return undefined !== _wm_ctx_content.get(this)
  retain(raw_content) :: _wm_ctx_content.set(this, raw_content); return this
  free() :: _wm_ctx_content.delete(this); return this

  async as_store_pair() ::
    return @[] this.key_loc, await this.encipher_content()

  async encipher_content() ::
    const raw_content = this.local()
    if undefined === raw_content ::
      throw new Error('No associated raw_content')
    return raw_content

  async decipher_content(enc_content) ::
    this.retain(enc_content)
    return enc_content

  async store(attr) ::
    const {storage, key_loc} = this
    await storage.store_at @
      key_loc, await this.encipher_content()
    return this.as_attr(attr)

  async as_attr(attr) ::
    return ! attr ? this : this[attr]

  exists() ::
    const {storage, key_loc} = this
    return storage.exists_at @ key_loc

  fetch_utf8() ::
    return this.fetch().then(u8_to_utf8)

  async fetch() ::
    const raw_content = this.local()
    if undefined !== raw_content ::
      return raw_content

    const p = this._do_fetch()
    this.retain(p)
    return p

  async _do_fetch() ::
    const {storage, key_loc} = this
    const enc_content = await storage.fetch_at(key_loc)
    return enc_content instanceof Uint8Array
      ? this.decipher_content(enc_content)
      : enc_content

